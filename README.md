# Лабораторная работа #3

## Тема: Объединения и перечисления в языке C

---

## Задача 1 - Указатель на объединение
**Постановка задачи**  
Напишите программу, которая использует указатель на некоторое объединение (union). Создайте и проинициализируйте переменные в объединении через указатель, затем выведите их значения на экран.

**Математическая модель**  
Объединение позволяет хранить разные типы данных в одной области памяти. Указатель на объединение предоставляет доступ к этой области.

**Список идентификаторов**
| Имя переменной | Тип данных | Смысловое обозначение |
|---|---|---|
| `Val` | `union` | Объединение для разных типов данных |
| `a` | `int` | Целое число |
| `b` | `float` | Число с плавающей точкой |
| `p` | `Val*` | Указатель на объединение |
| `x` | `Val` | Экземпляр объединения |

**Код программы**
```c
#include <stdio.h>

union Val {
    int a;
    float b;
};

int main() {
    union Val x;
    union Val *p = &x;
    
    p->a = 25;
    printf("Integer: %d\n", p->a);
    
    p->b = 5.5;
    printf("Float: %.1f\n", p->b);
    
    printf("After float, integer is: %d\n", p->a);
    
    return 0;
}
```

**Результаты выполненной работы**
```
Integer: 25
Float: 5.5
After float, integer is: 1085276160
```

---

## Задача 2 - Побайтовая распечатка числа
**Постановка задачи**  
Напишите программу, которая использует объединение (union) для побайтовой распечатки значения переменной типа unsigned long. Каждый байт должен быть выведен отдельно через указатель на char.

**Математическая модель**  
Число типа unsigned long занимает 4 байта (32 бита) или 8 байт (64 бита) в зависимости от системы. Через объединение получаем доступ к отдельным байтам.

**Список идентификаторов**
| Имя переменной | Тип данных | Смысловое обозначение |
|---|---|---|
| `Num` | `union` | Объединение для побайтового доступа |
| `v` | `unsigned long` | Целое число |
| `b` | `unsigned char[8]` | Массив байтов |
| `n` | `Num` | Экземпляр объединения |

**Код программы**
```c
#include <stdio.h>

union Num {
    unsigned long v;
    unsigned char b[8];
};

int main() {
    union Num n;
    n.v = 0xAABBCCDDEEFF1122;
    
    printf("Number: 0x%lX\n", n.v);
    printf("Bytes: ");
    
    for (int i = 0; i < 8; i++) {
        printf("%02X ", n.b[i]);
    }
    printf("\n");
    
    n.v = 1000;
    printf("\nNumber: %lu\n", n.v);
    printf("Bytes: ");
    
    for (int i = 0; i < 8; i++) {
        printf("%02X ", n.b[i]);
    }
    printf("\n");
    
    return 0;
}
```

**Результаты выполненной работы**
```
Number: 0xAABBCCDDEEFF1122
Bytes: 22 11 FF EE DD CC BB AA 

Number: 1000
Bytes: E8 03 00 00 00 00 00 00 
```

---

## Задача 3 - Перечисление дней недели
**Постановка задачи**  
Создайте перечислимый тип данных (enum) для семи дней недели. Реализуйте программу, которая выводит на экран значения каждого дня недели как целое число.

**Математическая модель**  
Перечисление (enum) присваивает целочисленные значения символьным константам, начиная с 0.

**Список идентификаторов**
| Имя переменной | Тип данных | Смысловое обозначение |
|---|---|---|
| `Week` | `enum` | Перечисление дней недели |
| `d` | `Week` | Переменная типа Week |

**Код программы**
```c
#include <stdio.h>

enum Week {
    ПН, ВТ, СР, ЧТ, ПТ, СБ, ВС
};

int main() {
    printf("Дни недели:\n");
    
    enum Week d = ПН;
    printf("Понедельник: %d\n", d);
    
    d = ВТ;
    printf("Вторник: %d\n", d);
    
    d = СР;
    printf("Среда: %d\n", d);
    
    d = ЧТ;
    printf("Четверг: %d\n", d);
    
    d = ПТ;
    printf("Пятница: %d\n", d);
    
    d = СБ;
    printf("Суббота: %d\n", d);
    
    d = ВС;
    printf("Воскресенье: %d\n", d);
    
    printf("\nВсе дни (цикл):\n");
    for (int i = ПН; i <= ВС; i++) {
        printf("%d ", i);
    }
    printf("\n");
    
    return 0;
}
```

**Результаты выполненной работы**
```
Дни недели:
Понедельник: 0
Вторник: 1
Среда: 2
Четверг: 3
Пятница: 4
Суббота: 5
Воскресенье: 6

Все дни (цикл):
0 1 2 3 4 5 6
```

---

## Задача 4 - Размеченное объединение
**Постановка задачи**  
Создайте размеченное объединение (union), которое заключено в структуре. Структура должна также содержать перечисление (enum), служащее индикатором того, какой тип данных хранится в объединении на текущий момент. Создайте динамический массив таких структур и реализуйте функцию для распечатки их содержимого на экран.

**Математическая модель**  
Размеченное объединение = структура с объединением + перечисление-тег для отслеживания текущего типа данных.

**Список идентификаторов**
| Имя переменной | Тип данных | Смысловое обозначение |
|---|---|---|
| `Var` | `struct` | Структура с размеченным объединением |
| `t` | `enum Type` | Тип хранимых данных |
| `val` | `union Data` | Объединение для данных |
| `arr` | `Var*` | Динамический массив структур |

**Код программы**
```c
#include <stdio.h>
#include <stdlib.h>

enum Type { ЧИСЛО, ВЕЩ, СИМВОЛ };

union Data {
    int i;
    double d;
    char c;
};

struct Var {
    enum Type t;
    union Data val;
};

void pr(struct Var v) {
    switch (v.t) {
        case ЧИСЛО:
            printf("Целое: %d\n", v.val.i);
            break;
        case ВЕЩ:
            printf("Вещественное: %.2f\n", v.val.d);
            break;
        case СИМВОЛ:
            printf("Символ: %c\n", v.val.c);
            break;
    }
}

int main() {
    struct Var *arr = malloc(4 * sizeof(struct Var));
    
    arr[0].t = ЧИСЛО;
    arr[0].val.i = 100;
    
    arr[1].t = ВЕЩ;
    arr[1].val.d = 2.71;
    
    arr[2].t = СИМВОЛ;
    arr[2].val.c = 'Z';
    
    arr[3].t = ЧИСЛО;
    arr[3].val.i = 999;
    
    printf("Массив:\n");
    for (int i = 0; i < 4; i++) {
        pr(arr[i]);
    }
    
    free(arr);
    
    return 0;
}
```

**Результаты выполненной работы**
```
Массив:
Целое: 100
Вещественное: 2.71
Символ: Z
Целое: 999
```

---

## Задача 5 - Ввод и хранение данных о студентах
**Постановка задачи**  
Создайте структуру, в которой используется объединение для хранения различных типов данных: например, структура с отдельным полем для имени студента и отдельное поле – целое число для его возраста либо строка его возраста словами. Реализуйте программу для динамического ввода данных о студентах и вывода их на экран.

**Математическая модель**  
Структура Student содержит имя и объединение для возраста (целое число или строка).

**Список идентификаторов**
| Имя переменной | Тип данных | Смысловое обозначение |
|---|---|---|
| `Stud` | `struct` | Структура студента |
| `name` | `char[30]` | Имя студента |
| `type` | `int` | Тип возраста (0 - число, 1 - строка) |
| `age` | `union Age` | Объединение для возраста |
| `list` | `Stud*` | Динамический массив студентов |

**Код программы**
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

union Age {
    int num;
    char str[50];
};

struct Stud {
    char name[50];
    int type;
    union Age age;
};

int main() {
    int n;
    printf("Количество студентов: ");
    scanf("%d", &n);
    while (getchar() != '\n');  // Полностью очищаем буфер
    
    struct Stud *list = malloc(n * sizeof(struct Stud));
    
    for (int i = 0; i < n; i++) {
        printf("\nСтудент %d:\n", i+1);
        
        printf("Имя: ");
        fgets(list[i].name, 50, stdin);
        list[i].name[strcspn(list[i].name, "\n")] = '\0';
        
        printf("Тип возраста (0=число, 1=строка): ");
        char type_str[10];
        fgets(type_str, 10, stdin);
        list[i].type = atoi(type_str);
        
        if (list[i].type == 0) {
            printf("Возраст (число): ");
            char num_str[20];
            fgets(num_str, 20, stdin);
            list[i].age.num = atoi(num_str);
        } else {
            printf("Возраст (строка): ");
            fgets(list[i].age.str, 50, stdin);
            list[i].age.str[strcspn(list[i].age.str, "\n")] = '\0';
        }
    }
    
    printf("\n=== Студенты ===\n");
    for (int i = 0; i < n; i++) {
        printf("%s - ", list[i].name);
        if (list[i].type == 0) {
            printf("%d лет\n", list[i].age.num);
        } else {
            printf("%s\n", list[i].age.str);
        }
    }
    
    free(list);
    return 0;
}
```

**Результаты выполненной работы**
```
Количество студентов: 3

Студент 1:
Имя: Петр
Тип возраста (0=число, 1=строка): 0
Возраст (число): 21

Студент 2:
Имя: Мария
Тип возраста (0=число, 1=строка): 1
Возраст (строка): двадцать три

Студент 3:
Имя: Алексей
Тип возраста (0=число, 1=строка): 0
Возраст (число): 19

=== Студенты ===
Петр - 21 лет
Мария - двадцать три
Алексей - 19 лет
```

---

## Задача 6 - Управление состояниями системы через enum
**Постановка задачи**  
Используйте перечисление (enum) для управления состояниями некоторой условной системы, например, старт, стоп, пауза. Напишите программу, которая изменяет состояние системы и выводит текущее состояние на экран.

**Математическая модель**  
Конечный автомат с состояниями: ОЖИДАНИЕ, РАБОТА, ПАУЗА, ОСТАНОВ.

**Список идентификаторов**
| Имя переменной | Тип данных | Смысловое обозначение |
|---|---|---|
| `State` | `enum` | Перечисление состояний системы |
| `s` | `State` | Текущее состояние системы |

**Код программы**
```c
#include <stdio.h>

enum State {
    ОЖИДАНИЕ, РАБОТА, ПАУЗА, ОСТАНОВ
};

const char* name(enum State s) {
    switch(s) {
        case ОЖИДАНИЕ: return "ОЖИДАНИЕ";
        case РАБОТА: return "РАБОТА";
        case ПАУЗА: return "ПАУЗА";
        case ОСТАНОВ: return "ОСТАНОВ";
        default: return "НЕИЗВЕСТНО";
    }
}

int main() {
    enum State s = ОЖИДАНИЕ;
    
    printf("Начальное состояние: %s\n", name(s));
    
    s = РАБОТА;
    printf("Перешли в: %s\n", name(s));
    
    s = ПАУЗА;
    printf("Перешли в: %s\n", name(s));
    
    s = РАБОТА;
    printf("Перешли в: %s\n", name(s));
    
    s = ОСТАНОВ;
    printf("Перешли в: %s\n", name(s));
    
    printf("\nРабота цикла:\n");
    enum State states[] = {ОЖИДАНИЕ, РАБОТА, ПАУЗА, РАБОТА, ОСТАНОВ};
    for (int i = 0; i < 5; i++) {
        printf("Шаг %d: %s\n", i, name(states[i]));
    }
    
    return 0;
}
```

**Результаты выполненной работы**
```
Начальное состояние: ОЖИДАНИЕ
Перешли в: РАБОТА
Перешли в: ПАУЗА
Перешли в: РАБОТА
Перешли в: ОСТАНОВ

Работа цикла:
Шаг 0: ОЖИДАНИЕ
Шаг 1: РАБОТА
Шаг 2: ПАУЗА
Шаг 3: РАБОТА
Шаг 4: ОСТАНОВ
```

---

## Задача 7 - Оптимизация памяти для хранения данных о температуре и влажности
**Постановка задачи**  
Создайте структуру с битовыми полями для хранения показаний температуры (в градусах Цельсия) и влажности (в процентах). Реализуйте ввод данных с клавиатуры и их корректное хранение в структуре с минимальным потреблением памяти.
- Температура может быть от -50 до +50 градусов Цельсия (нужно выделить минимальное количество бит).
- Влажность может быть от 0 до 100%.

**Математическая модель**  
Температура: -50..+50 → диапазон 101 значение → 7 бит (2⁷=128 ≥ 101)  
Влажность: 0..100 → диапазон 101 значение → 7 бит  
Итого: 14 бит ≈ 2 байта.

**Список идентификаторов**
| Имя переменной | Тип данных | Смысловое обозначение |
|---|---|---|
| `Sens` | `struct` | Структура с битовыми полями |
| `t` | `signed int : 7` | Температура (-50..50) |
| `h` | `unsigned int : 7` | Влажность (0..100) |
| `s` | `Sens` | Экземпляр структуры |

**Код программы**
```c
#include <stdio.h>

struct Sens {
    signed int t : 7;
    unsigned int h : 7;
};

int main() {
    struct Sens s;
    int temp, hum;
    
    printf("Температура (-50 до 50): ");
    scanf("%d", &temp);
    
    printf("Влажность (0 до 100): ");
    scanf("%d", &hum);
    
    if (temp < -50) temp = -50;
    if (temp > 50) temp = 50;
    if (hum < 0) hum = 0;
    if (hum > 100) hum = 100;
    
    s.t = temp;
    s.h = hum;
    
    printf("\nСохраненные значения:\n");
    printf("Температура: %d°C\n", s.t);
    printf("Влажность: %d%%\n", s.h);
    
    printf("\nРазмер структуры: %lu байт\n", sizeof(struct Sens));
    
    return 0;
}
```

**Результаты выполненной работы**
```
Температура (-50 до 50): 18
Влажность (0 до 100): 65

Сохраненные значения:
Температура: 18°C
Влажность: 65%

Размер структуры: 4 байт
```

---

## Задача 8 - Ввод и вывод через enum и union
**Постановка задачи**  
Создайте программу, которая позволяет пользователю вводить и выводить информацию с различными типами данных через перечисления и объединения. Например, пользователь может выбрать ввод данных как числа или строки, и программа корректно сохранит и отобразит эти данные.

**Математическая модель**  
Программа использует размеченное объединение для хранения разных типов данных с перечислением-тегом.

**Список идентификаторов**
| Имя переменной | Тип данных | Смысловое обозначение |
|---|---|---|
| `Data` | `union` | Объединение для данных |
| `Type` | `enum` | Тип данных |
| `In` | `struct` | Структура для ввода |
| `ch` | `int` | Выбор типа данных |
| `in` | `In` | Входные данные |

**Код программы**
```c
#include <stdio.h>

enum Type { ЦЕЛОЕ, ТЕКСТ, ВЕЩЕСТВЕННОЕ };

union Data {
    int i;
    char s[40];
    double d;
};

struct In {
    enum Type t;
    union Data data;
};

int main() {
    struct In in;
    int ch;
    
    printf("Выберите тип:\n");
    printf("1. Целое число\n");
    printf("2. Текст\n");
    printf("3. Вещественное число\n");
    printf("Выбор: ");
    scanf("%d", &ch);
    getchar();
    
    if (ch == 1) {
        in.t = ЦЕЛОЕ;
        printf("Введите целое число: ");
        scanf("%d", &in.data.i);
    } else if (ch == 2) {
        in.t = ТЕКСТ;
        printf("Введите текст: ");
        fgets(in.data.s, 40, stdin);
        in.data.s[strcspn(in.data.s, "\n")] = 0;
    } else {
        in.t = ВЕЩЕСТВЕННОЕ;
        printf("Введите вещественное число: ");
        scanf("%lf", &in.data.d);
    }
    
    printf("\nСохраненные данные:\n");
    if (in.t == ЦЕЛОЕ) {
        printf("Тип: Целое число\n");
        printf("Значение: %d\n", in.data.i);
    } else if (in.t == ТЕКСТ) {
        printf("Тип: Текст\n");
        printf("Значение: %s\n", in.data.s);
    } else {
        printf("Тип: Вещественное число\n");
        printf("Значение: %.3f\n", in.data.d);
    }
    
    return 0;
}
```

**Результаты выполненной работы**
```
Выберите тип:
1. Целое число
2. Текст
3. Вещественное число
Выбор: 3
Введите вещественное число: 12.345

Сохраненные данные:
Тип: Вещественное число
Значение: 12.345
```

---

## Информация о студенте
Иванова Елизавета, 1 курс, ПОО
